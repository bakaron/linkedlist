#ifndef AISDI_LINEAR_LINKEDLIST_H
#define AISDI_LINEAR_LINKEDLIST_H

#include <cstddef>
#include <initializer_list>
#include <stdexcept>

namespace aisdi
{

template <typename Type>
class LinkedList
{
public:
  using difference_type = std::ptrdiff_t;
  using size_type = std::size_t;
  using value_type = Type;
  using pointer = Type*;
  using reference = Type&;
  using const_pointer = const Type*;
  using const_reference = const Type&;

  class ConstIterator;
  class Iterator;
  using iterator = Iterator;
  using const_iterator = ConstIterator;
private:
struct node{
//public:
  Type var;
  node *next;
  node *prev;

 node(){
 next=prev=nullptr;
 }
node(const Type item):var(item)
{
  next=prev=nullptr;}
};
 size_type list_size;
 node *head;
 node *tail;
 size_type l_size;
public:


  LinkedList()
  {
  tail=new node;
  head=tail;
  l_size=0;
  }

  LinkedList(std::initializer_list<Type> l): LinkedList()
  {

  /*  for(auto it=l.begin();it!= l.end();it++){
    tail->next= new node;
    tail->var=*it;
    tail->next->prev=tail;
    tail=tail->next;
    l_size+=1;
*/for(auto it=l.begin();it!= l.end();it++)
        append(*it);
   // };
  // (void)l; // disables "unused argument" warning, can be removed when method is implemented.
  //throw std::runtime_error("TODO");
  }

  LinkedList(const LinkedList& other):LinkedList()
  {
    l_size=0;
   for(auto i =other.begin();i!=other.end();i++){
        append(*i);
   }

    //(void)other;
   // throw std::runtime_error("TODO");
  }

  LinkedList(LinkedList&& other)
  {
    l_size=other.l_size;
    head=other.head;
    tail=other.tail;

    other.tail=nullptr;
    other.tail=nullptr;
    other.l_size=0;
   // (void)other;
    //throw std::runtime_error("TODO");
  }

  ~LinkedList()
  {
    if(l_size==0) return;
    erase(begin(),end());
    head=tail=nullptr;
  }

  LinkedList& operator=(const LinkedList& other)
  {
   if(this==&other) return *this;//usuwa poprzedniÄ…
   for(unsigned int i=0;i<l_size;i++){
    popFirst();
   }
    for(auto i =other.begin();i!=other.end();i++){
        append(*i);
   }
   return *this;


    //(void)other;
   // throw std::runtime_error("TODO");
  }

  LinkedList& operator=(LinkedList&& other)
  {
    l_size=other.l_size;
    head=other.head;
    tail=other.tail;

    other.tail=nullptr;
    other.tail=nullptr;
    other.l_size=0;

    return *this;
    //(void)other;
    //throw std::runtime_error("TODO");
  }

  bool isEmpty() const
  {
    return head==tail? 1:0;
    //throw std::runtime_error("TODO");
  }

  size_type getSize() const
  {
    return l_size;
    //throw std::runtime_error("TODO");
  }

  void append(const Type& item)//ok
  {
   // node *help=new node(item);
    //node *temp=tail->prev;
    //tail->var=item;
    tail->next=new node;
    tail->var=item;
    tail->next->prev=tail;
    tail=tail->next;
    l_size++;
    //node*help=new node(item);
    //tail->prev->next=help;
    //help->prev=tail->prev;
    //help->next=tail;
    //tail->prev=help;

   // (void)item;
   // throw std::runtime_error("TODO");
  }

  void prepend(const Type& item)
  {
    node *help= new node;
    l_size++;
    help->next=head;
    head->prev=help;
    head=help;
    head->var=item;


    //(void)item;
    //throw std::runtime_error("TODO");
  }

  void insert(const const_iterator& insertPosition, const Type& item)
  {
  node *helper=new node(item);
  helper->next=insertPosition.node_pt->next;
  helper->next->prev=helper;
  insertPosition.node_pt->next=helper;
  helper->prev=insertPosition.node_pt;
  l_size+=1;
    //(void)insertPosition;
    //(void)item;
    //throw std::runtime_error("TODO");
  }

  Type popFirst()//nie ok
  {

    Type l=head->var;
    node *help=head;
    head=head->next;
    head->prev=nullptr;
    delete help;
    l_size--;

    return l;
   // throw std::runtime_error("TODO");
  }

  Type popLast()//not ok
  {
    Type l=head->var;
    l_size--;
    if(head->next==tail){

      delete head;

      head=tail;
      tail->prev=nullptr;
      return l;
    }
    node *help = tail->prev;
    tail->prev = help->prev;
    help->prev->next=tail;
    l=help->var;
    delete help;
    return l;

   // throw std::runtime_error("TODO");
  }

  void erase(const const_iterator& possition)
  {
  if(possition.node_pt==tail ||possition.node_pt==nullptr)
  {return;}
  possition.node_pt->next->prev=possition.node_pt->prev;
  possition.node_pt->prev->next=possition.node_pt->next;
  l_size--;
  delete possition.node_pt;



    //(void)possition;
    //throw std::runtime_error("TODO");
  }

  void erase(const const_iterator& firstIncluded, const const_iterator& lastExcluded)
  {
    for(const_iterator it= firstIncluded;it !=lastExcluded;it++ ){
        erase(it);
    }


    (void)firstIncluded;
    (void)lastExcluded;
    throw std::runtime_error("TODO");
  }

  iterator begin()
  {

  return Iterator(this,head);
    //throw std::runtime_error("TODO");
  }

  iterator end()
  {
  return Iterator(this,tail);
    //throw std::runtime_error("TODO");
  }

  const_iterator cbegin() const
  {
    return ConstIterator(this,head);

    //throw std::runtime_error("TODO");
  }

  const_iterator cend() const
  {
  return ConstIterator(this,tail);

    //throw std::runtime_error("TODO");
  }

  const_iterator begin() const
  {
    return cbegin();
  }

  const_iterator end() const
  {
    return cend();
  }
};

template <typename Type>
class LinkedList<Type>::ConstIterator
{
friend LinkedList<Type>;
public:
  using iterator_category = std::bidirectional_iterator_tag;
  using value_type = typename LinkedList::value_type;
  using difference_type = typename LinkedList::difference_type;
  using pointer = typename LinkedList::const_pointer;
  using reference = typename LinkedList::const_reference;
private:
  const LinkedList *pt;
  node * node_pt;
  ConstIterator(const LinkedList<Type> *p,node *n):pt(p),node_pt(n)
  {}

public:
  explicit ConstIterator():pt(nullptr),node_pt(nullptr)
  {}

  reference operator*() const//not ok
  {

    return node_pt->var;
    //throw std::runtime_error("TODO");
  }

  ConstIterator& operator++()
  {
    if(node_pt->next->next!=nullptr){node_pt=node_pt->next;}
    return *this;
    //throw std::runtime_error("TODO");
  }

  ConstIterator operator++(int)
  {
    ConstIterator temp=*this;
    if(node_pt->next->next!=nullptr){node_pt=node_pt->next;}
    return temp;
    //throw std::runtime_error("TODO");
  }

  ConstIterator& operator--()
  {

     if(node_pt->prev!=nullptr){node_pt=node_pt->prev;}
    return *this;
    //throw std::runtime_error("TODO");
  }

  ConstIterator operator--(int)
  {
    ConstIterator temp=*this;
    if(node_pt->prev!=nullptr){node_pt=node_pt->prev;}
    return temp;
    //throw std::runtime_error("TODO");
  }

  ConstIterator operator+(difference_type d) const
  {

    node *temp=node_pt;
   for(unsigned int i=0;i<d;i++){
   if(temp->next->next!=nullptr){temp=temp->next;}
   else break;
   }
   return ConstIterator(this->pt,temp);
  // return ConstIterator(pointer,temp);
    //return *this;
    //(void)d;
    //throw std::runtime_error("TODO");
  }

  ConstIterator operator-(difference_type d) const
  {

    node *temp=node_pt;
   for(unsigned int i=0;i<d;i++){
   if(temp->prev!=nullptr){temp=temp->prev;}
   else break;
   }
   return ConstIterator(this->pt,temp);
    //(void)d;
   // throw std::runtime_error("TODO");
  }

  bool operator==(const ConstIterator& other) const
  {
    return other.node_pt==node_pt &&other.pt==pt?1:0;
   // (void)other;
   // throw std::runtime_error("TODO");
  }

  bool operator!=(const ConstIterator& other) const
  {
    return !(*this==other);
   // (void)other;
  //  throw std::runtime_error("TODO");
  //  throw std::runtime_error("TODO");
  }
};

template <typename Type>
class LinkedList<Type>::Iterator : public LinkedList<Type>::ConstIterator
{
public:
  using pointer = typename LinkedList::pointer;
  using reference = typename LinkedList::reference;

    Iterator( LinkedList<Type> *p,node *n)
    {ConstIterator(p,n);}
  explicit Iterator()
  {}

  Iterator(const ConstIterator& other)
    : ConstIterator(other)
  {}

  Iterator& operator++()
  {
    ConstIterator::operator++();
    return *this;
  }

  Iterator operator++(int)
  {
    auto result = *this;
    ConstIterator::operator++();
    return result;
  }

  Iterator& operator--()
  {
    ConstIterator::operator--();
    return *this;
  }

  Iterator operator--(int)
  {
    auto result = *this;
    ConstIterator::operator--();
    return result;
  }

  Iterator operator+(difference_type d) const
  {
    return ConstIterator::operator+(d);
  }

  Iterator operator-(difference_type d) const
  {
    return ConstIterator::operator-(d);
  }

  reference operator*() const
  {
    // ugly cast, yet reduces code duplication.
    return const_cast<reference>(ConstIterator::operator*());
  }
};

}

#endif // AISDI_LINEAR_LINKEDLIST_H
